with open('27_B.txt') as f: #Открываем файл
    f=list(map(int, f.readlines()))[1:] #Читаем файл, преобразуем все элементы в числа, и выкидываем первый эелемент
    
    mx=(float('-inf'), float('inf')) #Инициируем кортеж, в котором элемент 0 отвечает за сумму, элемент 1 - за длину
    ost=[(float('inf'), 0)]*89 #Инициируем список остатков, как список кортежей. Каждый кортеж отвечает за определённый остаток. Нулевой элемент кортежа отвечает за значение, первый за длину
    summa=0 #Начальная сумма

    for i in range(len(f)): #Проходимся по списку. Важно именно так, чтобы следить за индексом
        summa+=f[i] #Добавляем текущий элемент к сумм

        if summa%89==0 and summa>mx[0]: #Если сумма кратна 89 и больше максимума, то
            mx=(summa, i) #Перезаписываем кортеж mx с новыми данными: новая сумма и длина, равная текущему индекса. 
        elif ost[summa%89][0]!=(float('inf')): #Иначе если значение остатка существует, то
            ref_summa = summa-ost[summa%89][0] #оздаём промежуточную сумму, как сумма минус значение под остатком

            if ref_summa>mx[0] or ref_summa==mx[0] and i-ost[summa%89][1]<mx[1]: #И если при этом промежуточная сумма больше максимальной или равна максимально, но при этом длина меньше, то
                mx=(ref_summa, i-ost[summa%89][1]) #Перезаписываем кортеж

        if summa<=ost[summa%89][0]: #Если сумма не превосходит значение под остатком, то
            ost[summa%89]=(summa, i) #Перезаписываем остаток. Это нужно для обновления остатка. Вдруг появится остаток меньше текущего. Или равный текущему. Но если равен текущему и стоит позже, следоательно, итоговая длина получится меньше
    print(mx[1]+1)#Выводим ответ как сумму длины плюс один. Нумерация индексом начинается с нуля, значит, длина меньше реальной на 1, равно как и разность двух чисел тоже меньше количества чисел в промежутке на 1
                
        

